<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hashtable" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/11/hashtable/" class="article-date">
  <time datetime="2019-02-11T08:09:24.000Z" itemprop="datePublished">2019-02-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/02/11/hashtable/">散列表：如何实现word编辑器的拼写检查？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Word文档编辑器大家应该经常使用吧，大家有没有留意到它编辑功能，当我们输入一个错误的单词时，单词单面就会标红提示“拼写错误”，这个功能是怎么实现的呢？其实啊，它是通过散列表实现的，学习了散列表原理后你就懂得这个功能的实现方式了。</p>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表的英文名叫Hash Table，一般叫散列表或哈希表，<strong>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表就是数组的一种扩展，由数组演化而来，可以说，如果没有数组就没有散列表。</strong></p>
<p>我用一个列子解释一下，我们去游泳馆游泳时一般都会寄存衣物，这时前台就会登记我们名字后分配一个储物柜编号卡，后面我们通过这个编号卡就能快速地找到柜子存储衣物，回去时也能快速找到柜子取回衣物。</p>
<p>这里储物柜是按照编号顺序排列，就相当于一个数组，由于每天去游泳的人都各不相同，就不能每个柜子都贴上对应人的名字了，所以储物前就会先去前台分配一个编号，再根据编号的下标存储在数组的下标位置。</p>
<p>这就是典型的散列思想。每个去游泳的人的名字我们叫做<strong>键</strong>(key)或者<strong>关键字</strong>。我们把前台通过名字分配储物柜号的对应过程叫作<strong>散列函数</strong>，而通过散列函数计算得到的储物柜号码叫作<strong>散列值</strong>。</p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数，顾名思义，它就是一个函数，我们可以把它定义为hash(key)，其中key就是元素的键，hash(key)就是通过散列函数计算得到的散列值。</p>
<p><img src="images/hash_function.png" alt=""></p>
<p>刚刚举的例子中，散列函数其实就是前台工作人员将名字和号码牌对应起来的一个对应关系，这个例子比较不恰当，并没有一个固定的公式。那么，实用场景中，要怎么设计构造散列函数呢，我总结了三点基本的要求：</p>
<ol>
<li>散列函数计算得到的散列值必须是一个非负整数；</li>
<li>key1 = key2，那hash(key1) = hash(key2);</li>
<li>key1 ≠ key2，那hash(key1) ≠ hash(key2);</li>
</ol>
<p>第一点很容易理解，散列值最后是作为数组的下标的，数组下标是从0开始的；第二点，相同的key，得到的散列值也应该是相同的。</p>
<p>第三点看起来合情合理，但是在真实场景中，要想找到一个不同的键得出的散列值都不一样的散列函数几乎是不可能的，即便像业界著名的MD5、SHA、CRC等哈希算法也无法避免<strong>散列冲突</strong>，因为数组的空间有限，函数计算得到的值还必须在数组个数范围内，因此就会有很大概率出现冲突。</p>
<h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>再好的散列函数也无法避免散列冲突，那怎么办呢？只能通过其他方式解决，一般散列冲突的解决办法有两类：<strong>开放寻址法</strong>和<strong>链表法</strong>。</p>
<h4 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1.开放寻址法"></a>1.开放寻址法</h4><p>开放寻址法的核心思想是，如果出现了散列冲突，就寻找下一个空闲位置，插入新的数据。开放寻址法也有多种方式，将介绍一个简单的探测方法，线性探测(Linear Probing)。</p>
<h6 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a><em>线性探测</em></h6><p>当我们往散列表插入数据时，如果经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置依次往后查找，将数据插入到找到的空闲位置，如果遍历到尾部仍没有空闲位置，我们就从表头开始找，直到找到为止。如图所示</p>
<p><img src="images/search_key.png" alt=""></p>
<p>通过线性探测要查找数据时，和插入数据类似，也是通过散列函数得到对应位置的元素，和要查询的数据作对比，如果一致，则取出该值，如果不一致，则从该位置往下到散列表的空闲位置一个个查找，如果找到，取出对应值，如果没有找到，则数据不存在。</p>
<p>而但通过线性探测法删除一个元素时就比较麻烦，如果查找到对应的元素时直接将该元素对应的位置置空的话，那按照上面说的线性探测查找方法，遇到一个空的位置时就停止查询，那这个空位置如果是刚刚被删除的元素，这时候这个查找方法就失败了。所以，删除一个元素时并不是直接删除，而是在要删除的位置标记deleted。在查找一个元素时如果遇到deleted标记的元素，则继续往下查找，如下图所示。</p>
<p><img src="images/delete_hash.png" alt=""></p>
<p>通过上面的介绍，我们可以知道，线性探测法有一个弊端。就是散列表剩余空间不足时，就会频繁地出现散列冲突，导致效率不高，极端情况下插入一个元素会时间复杂度为O(n)。</p>
<p>对于开放寻址的冲突解决方法，除了线性探测方法外，还有另外两种比较经典的探测方法，分别为<strong>二次探测</strong>和<strong>双重散列</strong>。</p>
<h6 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a><em>二次探测</em></h6><p>二次探测法，和线性探测法类似，线性探测每次的探测步长是1步，它探测的下标序列是hash(key)+0，hash(key)+1，hash(key)+2，hash(key)+3…而二次探测的步长是原来的“二次方步长”，它的探测下标序列是列是hash(key)+0，hash(key)+1，hash(key)+4，hash(key)+9…</p>
<h6 id="双重散列"><a href="#双重散列" class="headerlink" title="双重散列"></a><em>双重散列</em></h6><p>双重散列，意思是不仅要使用一个散列函数，我们要使用一组散列函数hash1(key)，hash2(key)，hash3(key)…先使用第一个散列函数计算散列位置，如果出现冲突，再使用第二个散列函数，依次类推，直到找到空闲位置。</p>
<p>不管使用哪种线性冲突解决方法，当空闲位置较少的时候，出现冲突的概率就会加大，为了保证散列表的操作效率，一般会保证散列表有一定比例的空闲位置，我们用<strong>装载因子</strong>来表示散列表的空闲比例，它的计算公式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">散列表的装载因子 = 填入表中的元素个数 / 散列表长度</span><br></pre></td></tr></table></figure></p>
<h4 id="2-链表法"><a href="#2-链表法" class="headerlink" title="2.链表法"></a>2.链表法</h4><p>链表法是一种更加普遍的散列表冲突解决方法，相比线性探测法，它更简单更容易理解。如图所示，散列表的元素就是一个“桶”或“槽”，每个桶都放入一个链表，将散列值相同的元素都放在同一个链表中。</p>
<p><img src="images/linked_hash.png" alt=""></p>
<p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应的链表中即可，时间复杂度为O(1)。当要查询或删除时，即通过同样的方法找到对应的槽位，再遍历链表查询或删除，那查询和删除的时间复杂度是多少呢？</p>
<p>查询和删除的时间复杂度和每个槽位链表的长度成正比，假设链表平均长度为k，那时间复杂度则为O(k)。对于散列比较均匀的散列函数，理论上k = n / m，其中n为散列表中数据的个数，m为散列表的长度。</p>
<h3 id="解答开篇"><a href="#解答开篇" class="headerlink" title="解答开篇"></a>解答开篇</h3><p>有了上面的散列表的介绍，我们再来回顾下开篇提到的Word文档编辑器的拼写错误提示是怎么实现的？</p>
<p>我们常用的英文单词大约有20万个左右，假设平均每个单词有10个字母，那每个单词就大约有10个字节，20万个单词就有差不多2M左右的大小，对于现代的计算机来说，完全可以将20万个单词放在内存中，存储在散列表，每次输入一个单词时，就通过散列表查找，如果能找到就是拼写正确的，如果找不到则提示拼写错误。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/11/hashtable/" data-id="cjs02rbt50007zgo9my9cbynx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017-7-15-source" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/15/2017-7-15-source/" class="article-date">
  <time datetime="2017-07-15T07:36:00.000Z" itemprop="datePublished">2017-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/15/2017-7-15-source/">从一碗面想到的装饰模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p><strong>装饰器模式（Decorator Pattern）</strong>允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>
</blockquote>
<h3 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h3><p><em>在厦门的小伙伴们一定对沙茶面很熟悉，作为厦门的一个特色小吃，大街小巷到处能看到挂有“沙茶面”招牌的面馆，味道鲜美，可以加各种配料，是外地游客必吃的一种小吃。</em></p>
<p>假设面馆现在要做一个沙茶面订单系统，能计算出每一碗面的价格。而面馆有两种面，一种沙茶面，一种清汤面，两种面有不同的定价，一开始我们可能会这样设计的，定义两种面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-f7ff3f888aaf0345.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>每一碗面顾客可以加配料，有瘦肉、猪肝、鱿鱼等，每一种配料都有不同的价格，清汤面和沙茶面加了不同的料更是有多种价格，接下去怎么处理呢？可能你会想到用成员变量加继承方式，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-9dc845d5f4d9437d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这样每一碗面都可以设置自己的配料，在计算价格调用cost()时就可以根据Noddle对象是否含有对应的配料，有的话再加上配料的价钱就能计算出这碗面的价格；</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>这样处理有点问题，假如现在面馆又增加了一种配料，比如老板今天新进了花蛤、肉丸，这时候Noddle基类还得加上这两种配料的成员，每加一种配料，基类就要改动一次，这样明显违背了设计模式：<strong>对扩展开发，对修改关闭</strong>的重要原则。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>这时候我们就可以使用装饰器模式了，它能使我们加每一种调料时可以不改变原有的面的属性，极大地提高了灵活性和可扩展性，下面介绍一下通过装饰模式处理的步骤：</p>
<h5 id="1-创建Noddle基类"><a href="#1-创建Noddle基类" class="headerlink" title="1. 创建Noddle基类"></a>1. 创建Noddle基类</h5><p>抽象面条类有mDescription标注是哪一种面条，mPrice为定价，每一种面的价格和名称都在子类重写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Noddle &#123;</span><br><span class="line"></span><br><span class="line">    public String mDescription = &quot;Unknow Noddle&quot;;</span><br><span class="line"></span><br><span class="line">    public float mPrice = 0.0f;</span><br><span class="line"></span><br><span class="line">    public String getDescription()&#123;</span><br><span class="line">        return mDescription;</span><br><span class="line">    &#125;</span><br><span class="line">    public float cost()&#123;</span><br><span class="line">        return mPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-实现两种面：沙茶面和清汤面"><a href="#2-实现两种面：沙茶面和清汤面" class="headerlink" title="2. 实现两种面：沙茶面和清汤面"></a>2. 实现两种面：沙茶面和清汤面</h5><p>假设沙茶面每碗不含任何配料定价15块，清汤面每碗不含任何配料定价10块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class SatayNoddle extends Noddle &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return &quot;SatayNoddle&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float cost() &#123;</span><br><span class="line">        return 15.0f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class LightSoupNoddle extends Noddle &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return &quot;LightSoupNoddle&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public float cost() &#123;</span><br><span class="line">        return 10.0f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-创建抽象装饰类"><a href="#3-创建抽象装饰类" class="headerlink" title="3. 创建抽象装饰类"></a>3. 创建抽象装饰类</h5><p>这个类持有一个Noddle对象，而自己本身也是Noddle类型，这样能保持动作一致性，都有cost()方法，而且cost可以在调用成员变量的cost()方法基础上再加上自己额外的处理，即能计算被装饰者的价格外还能加上自己的价格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">abstract class DecorateNoddle extends Noddle &#123;</span><br><span class="line"></span><br><span class="line">    public Noddle mNoddle;</span><br><span class="line"></span><br><span class="line">    public DecorateNoddle(Noddle noddle)&#123;</span><br><span class="line">        mNoddle = noddle;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return mNoddle.getDescription() + mDescription;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float cost() &#123;</span><br><span class="line">        return mNoddle.cost() + mPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-实现两种配料：瘦肉和猪肝，它们属于装饰者"><a href="#4-实现两种配料：瘦肉和猪肝，它们属于装饰者" class="headerlink" title="4. 实现两种配料：瘦肉和猪肝，它们属于装饰者"></a>4. 实现两种配料：瘦肉和猪肝，它们属于装饰者</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LeanBurdening extends DecorateNoddle &#123;</span><br><span class="line"></span><br><span class="line">    public LeanBurdening(Noddle noddle) &#123;</span><br><span class="line">        super(noddle);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        mDescription = &quot; + Lean&quot;;</span><br><span class="line">        return super.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float cost() &#123;</span><br><span class="line">        mPrice = 1.5f;</span><br><span class="line">        return super.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class LiverBurdening extends DecorateNoddle &#123;</span><br><span class="line"></span><br><span class="line">    public LiverBurdening(Noddle noddle) &#123;</span><br><span class="line">        super(noddle);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        mDescription = &quot; + Liver&quot;;</span><br><span class="line">        return super.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public float cost() &#123;</span><br><span class="line">        mPrice = 2.0f;</span><br><span class="line">        return super.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样准备工作就做好了，这里总结一下装饰模式的工作流程，假设一个顾客点了一碗沙茶面，加了瘦肉和猪肝配料，这是就有如下处理：</p>
<p><strong>1. 创建一个沙茶面对象；</strong></p>
<p><strong>2. 创建一个瘦肉配料对象，这个配料装饰了沙茶面，即沙茶面对象是自己的成员变量，要计算价格时就可以把自己的价格机上沙茶面的价格；</strong></p>
<p><strong>3. 创建一个猪肝对象，同第2点；</strong></p>
<p><strong>4. 由于装饰对象两种配料和被装饰对象沙茶面都是Noddle类型，所以计算价格时只需要计算最外围的装饰对象的价格就能得出这碗面的总价格了。</strong></p>
<p>用如下代码处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class NoddleStoreDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        Noddle satayNoddle = new SatayNoddle();</span><br><span class="line">        satayNoddle = new LiverBurdening(satayNoddle);</span><br><span class="line">        satayNoddle = new LeanBurdening(satayNoddle);</span><br><span class="line">        System.out.println(satayNoddle.getDescription() + &quot;, price: &quot; + satayNoddle.cost());</span><br><span class="line"></span><br><span class="line">        Noddle lightSoupNoddle = new LightSoupNoddle();</span><br><span class="line">        lightSoupNoddle = new LiverBurdening(lightSoupNoddle);</span><br><span class="line">        lightSoupNoddle = new LeanBurdening(lightSoupNoddle);</span><br><span class="line">        System.out.println(lightSoupNoddle.getDescription() + &quot;, price: &quot; + lightSoupNoddle.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下输出的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SatayNoddle + Liver + Lean, price: 18.5</span><br><span class="line">LightSoupNoddle + Liver + Lean, price: 13.5</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-1d639aee7b699e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。这时就可以动态地给一个对象添加一些额外的职责，这样装饰类和被装饰类能独立发展，不相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p>示例代码<a href="https://github.com/zfc580/DesignPatternDemo" target="_blank" rel="noopener">戳这里</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/15/2017-7-15-source/" data-id="cjs02rbt10004zgo99h7xrhbu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017-7-8-source" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/08/2017-7-8-source/" class="article-date">
  <time datetime="2017-07-08T08:34:00.000Z" itemprop="datePublished">2017-07-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/08/2017-7-8-source/">用王者荣耀分析策略模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>策略模式（Strategy Pattern）<strong>使用了算法族，分别封装起来，让它们可以互相替换，此模式让算法的变化独立于使用算法的客户</strong>。这种类型的设计模式属于行为型模式。</p>
</blockquote>
<p>从上面的概念我们可以看得出来，策略模式主要有两个角色：<strong>算法族</strong>和<strong>使用算法的客户</strong>。算法族表示一系列的动作和操作，而使用算法的客户就是执行这些操作的主体。</p>
<p>最近王者荣耀大火，争议不断，突然想到用王者荣耀的例子解析一下正在学习的设计模式，学习和玩乐结合是最好的搭配，现在我就以王者荣耀为情景解释分析策略模式的操作。</p>
<p>#####1. 创建算法族：英雄技能</p>
<p>王者荣耀中每个英雄都有一套技能，每个英雄所拥有的技能都不一样，比如狄仁杰可以施放令牌技能，项羽有霸王斩技能，鲁班七号有无敌沙嘴炮技能，按照Java的封装、抽象特性，我们可以把技能抽象为一个接口，每一种技能实体都可以调用useSkill()执行技能；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface SkillBehavior &#123;</span><br><span class="line">    void useSkill(); //释放技能</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>英雄的技能多种多样，我们把每一种技能都封装为一个技能类，实现统一的接口SkillBehavior，这里举例介绍三种技能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ArrowSkill implements SkillBehavior&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void useSkill() &#123;</span><br><span class="line">        System.out.println(&quot;释放暗箭技能&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class KnifeSkill implements SkillBehavior &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void useSkill() &#123;</span><br><span class="line">        System.out.println(&quot;释放长刀技能&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class GunSkill implements SkillBehavior &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void useSkill() &#123;</span><br><span class="line">        System.out.println(&quot;释放手枪技能&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####2. 创建使用算法族客户：英雄</p>
<p>技能已经封装好了，还需要有使用技能的客户，那就是英雄了，每个英雄都有一个共性，那就是可以施放技能，我们就抽象封装出一个英雄类，每个英雄都持有一个技能对象，并可以调用performSkill()施放自己拥有的技能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Hero &#123;</span><br><span class="line"></span><br><span class="line">    public SkillBehavior mBehavior;</span><br><span class="line"></span><br><span class="line">    public Hero()&#123;</span><br><span class="line">        System.out.print(&quot;英雄出生 &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void performSkill()&#123;</span><br><span class="line">        if(mBehavior != null)&#123;</span><br><span class="line">            mBehavior.useSkill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setSkillBehavior(SkillBehavior behavior)&#123;</span><br><span class="line">        mBehavior = behavior;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>英雄类封装好了，这时就需要有具体的英雄了，这里我们举例了三位英雄，也是我比较熟悉的英雄：狄仁杰、项羽、鲁班七号，每个英雄都须继承自Hero类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class DiRenJie extends Hero &#123;</span><br><span class="line"></span><br><span class="line">    public DiRenJie()&#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;狄仁杰：代表法律制裁你...&quot;);</span><br><span class="line">        mBehavior = new ArrowSkill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class XiangYu extends Hero &#123;</span><br><span class="line"></span><br><span class="line">    public XiangYu()&#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;项羽：我命由我... &quot;);</span><br><span class="line">        mBehavior = new KnifeSkill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class LuBanQiHao extends Hero &#123;</span><br><span class="line"></span><br><span class="line">    public LuBanQiHao() &#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;鲁班七号：魔法大师，智障250，@￥%*&amp;￥#... &quot;);</span><br><span class="line">        mBehavior = new GunSkill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####3. 算法族客户使用算法：英雄施放技能<br>技能和英雄都准备好了，这时候就要应该开始施放技能了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class KingGorgeDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Hero mDi = new DiRenJie();</span><br><span class="line">        mDi.performSkill();</span><br><span class="line">        Hero mXiang = new XiangYu();</span><br><span class="line">        mXiang.performSkill();</span><br><span class="line">        Hero mLu = new LuBanQiHao();</span><br><span class="line">        mLu.performSkill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看各位英雄的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">英雄出生 狄仁杰：代表法律制裁你...</span><br><span class="line">释放暗箭技能</span><br><span class="line">英雄出生 项羽：我命由我... </span><br><span class="line">释放长刀技能</span><br><span class="line">英雄出生 鲁班七号：魔法大师，智障250，@￥%*&amp;￥# </span><br><span class="line">释放手枪技能</span><br></pre></td></tr></table></figure>
<p>#####4. 让算法族可以互相替换：英雄可以动态更换技能<br>在最开始策略模式的概念中有一句话：<strong>策略模式使用了算法族，分别封装起来，让它们可以互相替换</strong>。互相替换是什么概念呢，假设狄仁杰令牌技能使用腻了，想试一下鲁班七号的霸王枪技能，那只需要动态地给狄仁杰这个英雄设置一个GunSkill技能，后面就可以释放鲁班七号的技能了。大家可以发现在Hero里有一个方法setSkillBehavior()。操作如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class KingGorgeDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Hero mDi = new DiRenJie();</span><br><span class="line">        SkillBehavior gunSkill = new GunSkill();</span><br><span class="line">        mDi.setSkillBehavior(gunSkill);</span><br><span class="line">        mDi.performSkill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候的输出就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">英雄出生 狄仁杰：代表法律制裁你...</span><br><span class="line">释放手枪技能</span><br></pre></td></tr></table></figure>
<p>虽然这个例子有点不恰当，王者荣耀也不可能有这种操作，这只是一个简单的例子方便说明问题而已。可以举例一个实际场景：腾讯要推出狄仁杰的一项叫“神捕”的新技能，那只需要再封装一个执行SkillBehavior接口的技能类SeizeSkill，创建出SeizeSkill对象并设置给狄仁杰英雄对象，这时候释放技能时就是新的神捕技能了。</p>
<p>#####5. 策略模式的特性<br>策略模式对于软件开发来说是一种很好的设计模式，即英雄要替换技能时不用去改变英雄的类，技能和英雄互相独立，不耦合，可以用下面的类图表示策略模式的结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-dc91acc2a931b52e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>优点</strong>：1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。<br><strong>适用的场景</strong>：<br>1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。<br> 2、一个系统需要动态地在几种算法中选择一种。<br> 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
<p>示例代码<a href="https://github.com/zfc580/DesignPatternDemo" target="_blank" rel="noopener">戳这里</a>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/07/08/2017-7-8-source/" data-id="cjs02rbt20005zgo918x2yjyg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017-6-30-source" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/30/2017-6-30-source/" class="article-date">
  <time datetime="2017-06-30T07:56:00.000Z" itemprop="datePublished">2017-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/java/">java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/30/2017-6-30-source/">设计模式之工厂模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>工厂模式是最常用的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
</blockquote>
<p>工厂模式分为<strong>简单工厂模式</strong>和<strong>工厂方法模式</strong>两种。</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式主要有四种角色：</p>
<ul>
<li>抽象产品角色：接口或抽象类，定义一个产品的共有属性；</li>
<li>具体产品角色：对抽象产品的具体实现，由工厂类创建；</li>
<li>工厂类角色：创建具体产品类，产品都必须由该类实例化；</li>
<li>客户端：创建工厂类实例，通过工厂类简介创建产品类；</li>
</ul>
<p>结构图如下：<br><img src="http://upload-images.jianshu.io/upload_images/3334280-36029597728dd38d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>创建抽象产品角色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建三个具体产品对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Rectangle implements Shape&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;draw the Rectangle.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Square implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;draw the Square.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;draw the Circle.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常见工厂类角色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory &#123;</span><br><span class="line"></span><br><span class="line">    public final static int TYPE_RECTANGLE = 0;</span><br><span class="line">    public final static int TYPE_SQUARE = 1;</span><br><span class="line">    public final static int TYPE_CIRLE = 2;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Shape createShape(int type) &#123;</span><br><span class="line"></span><br><span class="line">        Shape mShape = null;</span><br><span class="line"></span><br><span class="line">        switch (type)&#123;</span><br><span class="line"></span><br><span class="line">            case TYPE_RECTANGLE:</span><br><span class="line">                mShape = new Rectangle();</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case TYPE_SQUARE:</span><br><span class="line">                mShape = new Square();</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case TYPE_CIRLE:</span><br><span class="line">                mShape = new Circle();</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return mShape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryPartternDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">        ShapeFactory mShapeFactory = new ShapeFactory();</span><br><span class="line">        Shape mRectangle = mShapeFactory.createShape(ShapeFactory.TYPE_RECTANGLE);</span><br><span class="line">        mRectangle.draw();</span><br><span class="line">        Shape mSquare = mShapeFactory.createShape(ShapeFactory.TYPE_SQUARE);</span><br><span class="line">        mSquare.draw();</span><br><span class="line">        Shape mCircle = mShapeFactory.createShape(ShapeFactory.TYPE_CIRLE);</span><br><span class="line">        mCircle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行后输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">draw the Rectangle.</span><br><span class="line">draw the Square.</span><br><span class="line">draw the Circle.</span><br></pre></td></tr></table></figure>
<h3 id="工厂模式的优点"><a href="#工厂模式的优点" class="headerlink" title="工厂模式的优点"></a>工厂模式的优点</h3><p>假设我们不使用工厂模式，要创建这三个具体产品类对象你可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class FactoryPartternDemo &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Rectangle rectangle = new Rectangle();</span><br><span class="line">        rectangle.draw();</span><br><span class="line">        Square square = new Square();</span><br><span class="line">        square.draw();</span><br><span class="line">        Circle circle = new Circle();</span><br><span class="line">        circle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样同样是输出了和上面一样的输出结果，而且代码量减少了，看起来好像这种方式会更好是不是。如果这样想的话你就too young too simple了。</p>
<p>根据<strong>依赖倒置</strong>原则：<strong>要依赖抽象，不依赖具体类。</strong></p>
<p>第二种写法客户端FactoryPartternDemo依赖了三个具体类，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-e89d358b52773c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>而第一种写法FactoryPartternDemo只依赖了抽象类Shape，它需要什么类型的对象，只需要向ShapeFactory传入一个类型值，就能获取到需要的对象，而不需要关心具体是什么类。</p>
<p>假设后面由于业务扩展，需要增加类似Oval, Rhombus等多个具体产品时，第二种写法会随着业务产品的增加，依赖的类也随着增加，而第一种写法不管增加多少业务类，它还是只依赖Shape抽象类。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/30/2017-6-30-source/" data-id="cjs02rbsz0003zgo9p349wgco" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017-4-13-source" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/14/2017-4-13-source/" class="article-date">
  <time datetime="2017-03-14T12:00:00.000Z" itemprop="datePublished">2017-03-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/14/2017-4-13-source/">Java中volatile的作用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>使用volatile时会涉及到并发编程相关问题，不可避免也会涉及到多线程的内存模型，因为通过volatile修饰的变量就是用来控制该变量的内存区域存储</p>
</blockquote>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>简单来说，Java内存可以分为本地内存和共享内存，本地内存是每个线程都各自拥有的一块内存区域，共享内存是所有线程共享的内存区域，为提高运行效率，线程会拷贝一份共享变量的内存到本地内存区域，直接对本地内存的变量操作，在适当时候才回写到共享内存中；如图所示<br><img src="http://upload-images.jianshu.io/upload_images/3334280-381e24fb1aa23065.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>如果变量A没有通过volatile修饰，则线程1运行时只会操作本地内存的变量A副本，在合适的时机才会把修改后的值刷回共享内存，而在刷回之前，线程2对线程1的变量副本是不可见的。而变量A通过volatile修饰后，则是这样的流程：（1）当一个线程要使用共享内存中的 volatile 变量时，如图中的变量A，它会直接从主内存中读取，而不使用自己本地内存中的副本。（2）当一个线程对一个 volatile 变量进行写时，它会将这个共享变量的值刷新到共享内存中。所以我们称volatile变量对其他线程具有可见性，但volatile不具有原子性(下面会提到)。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>使用synchronized修饰的代码块或方法，能保证同一时刻最多只有一个线程执行该代码块；synchronized使这个代码块具有原子性。举个实际例子：</p>
<ul>
<li>两个并发线程A和B访问同一个object对象的synchronized(this)代码块时，同一个时刻如果A访问了该代码块，另一个线程B再访问时会被阻塞；</li>
<li>当线程A访问object的一个synchronized(this)同步代码块时，线程B对object中所有其它synchronized(this)同步代码块的访问将被阻塞；</li>
</ul>
<p>某个线程访问了object对象的synchronized(this)代码块时，我们称该线程获得了object的锁，其他线程必须等待锁被释放后才能访问；我们通过一段代码分析原子性和可见性的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class ActomicityTest implements Runnable &#123;</span><br><span class="line">    private volatile int i = 0;</span><br><span class="line">    public int getValue()&#123;</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">    private synchronized void envenIncrement()&#123;</span><br><span class="line">        i++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            envenIncrement();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        ActomicityTest at = new ActomicityTest();</span><br><span class="line">        exec.execute(at);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int val = at.getValue();</span><br><span class="line">            if(val % 2 != 0)&#123;</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                System.exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序demo并发两个线程，一个线程连续调用两次i++，即每次+2，另一个线程取出i值，如发现i是奇数则退出程序，否则程序陷入死循环一直运行；而运行后的结果是，每次运行都会退出。<br>原因是getValue()虽然是原子性操作，但没有加锁，导致在envenIncrement()执行到第一个i++后，getValue()就执行了取到了奇数值；要解决此问题的话可以在getValue()加上synchronized，因为在envenIncrement()调用期间，如果线程切到调用getValue()的线程时，就会阻塞，保证synchronized修饰的envenIncrement()方法执行后才能执行下一个synchronized方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/14/2017-4-13-source/" data-id="cjs02rbsv0001zgo9u9qjqgwl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2017-2-26-source" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/26/2017-2-26-source/" class="article-date">
  <time datetime="2017-02-26T06:00:00.000Z" itemprop="datePublished">2017-02-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/26/2017-2-26-source/">Android视图创建原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>我们在开发android程序，如果要写一个界面，很自然就想到几个步骤：创建一个Activity类，写一个xml布局，在回调函数onCreate()通过setContentView()把xml布局文件设置进Activity，然后一个简单的界面就出来了，相当简单！可是，在这个过程中android系统到底经历了什么呢，作为一名应用开发工程师，我们大部分只关心上层的实现，并不清楚android系统层面的实现原理，这篇文章我将分析与Activity视图相关的对象Window、WindowManager和View的之间关系和它们创建过程。</p>
</blockquote>
<h2 id="Window的初始化过程"><a href="#Window的初始化过程" class="headerlink" title="Window的初始化过程"></a>Window的初始化过程</h2><hr>
<p>Activity有一个类型为Window的成员变量，它在Activity成员函数attach()被初始化，附上源码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Activity extends ContextThemeWrapper</span><br><span class="line">        implements LayoutInflater.Factory2,</span><br><span class="line">        Window.Callback, KeyEvent.Callback,</span><br><span class="line">        OnCreateContextMenuListener, ComponentCallbacks2,</span><br><span class="line">        Window.OnWindowDismissedCallback &#123;</span><br><span class="line">  ......</span><br><span class="line">  private Window mWindow;</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  final void attach(Context context, ActivityThread aThread,</span><br><span class="line">            Instrumentation instr, IBinder token, int ident,</span><br><span class="line">            Application application, Intent intent, ActivityInfo info,</span><br><span class="line">            CharSequence title, Activity parent, String id,</span><br><span class="line">            NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">            Configuration config, String referrer, IVoiceInteractor voiceInteractor) &#123;</span><br><span class="line">        attachBaseContext(context);</span><br><span class="line">        mFragments.attachHost(null /*parent*/);</span><br><span class="line">        mWindow = new PhoneWindow(this);</span><br><span class="line">        mWindow.setCallback(this);</span><br><span class="line">        mWindow.setOnWindowDismissedCallback(this);</span><br><span class="line">        mWindow.getLayoutInflater().setPrivateFactory(this);</span><br><span class="line">        if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">            mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">        &#125;</span><br><span class="line">        if (info.uiOptions != 0) &#123;</span><br><span class="line">            mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">        &#125;</span><br><span class="line">        ......    </span><br><span class="line">        mWindow.setWindowManager(null, mToken, mComponent.flattenToString());    </span><br><span class="line">        ......    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>整个代码的调用流程可以用下面的时序图来概括：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-02bc5b43624b851b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1"></p>
<h3 id="attach-函数主要做了以下几件事情："><a href="#attach-函数主要做了以下几件事情：" class="headerlink" title="attach()函数主要做了以下几件事情："></a>attach()函数主要做了以下几件事情：</h3><ul>
<li>初始化一个PhoneWindow对象并赋给mWindow，由此可知PhoneWindow是Window的子类，两者的关系可以参考下面的图2;</li>
<li>调用PhoneWindow的成员函数setCallback()设置Activity的回调，该回调用来通知键盘和触摸回调；</li>
<li>调用setSoftInputMode()设置描述窗口的软键盘输入区域的显示模式；</li>
<li>为PhoneWindow创建一个WindowManagerImpl对象并保存在成员变量mWindowManager中，WindowManagerImpl用来处理后面会讲到的View对象；</li>
</ul>
<p>Activity的所有视图相关的属性和布局对象都是通过PhoneWindow来维护的，我通过一个类图来体现Window和PhoneWindow的关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-e6dec4e61ab1271b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2"></p>
<h2 id="View的创建过程"><a href="#View的创建过程" class="headerlink" title="View的创建过程"></a>View的创建过程</h2><p>通过下面的时序图我们可以知道整View的创建过程<br><img src="http://upload-images.jianshu.io/upload_images/3334280-3384b473cf74ac90.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图3"></p>
<p>其中ActivityThread是创建Activity的一个处理类，通过这个类来处理Activity的生命周期，这个流程不是这篇文章讨论的范畴，我们只要知道系统经过一系列复杂的过程最终通过performLaunchActivity调用了Activity的onCreate函数，而我们要开发应用程序一般都会在onCreate函数调用setContentView来设置布局，最终调用了PhoneWindow的setContentView()，我们来看源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public class PhoneWindow extends Window implements MenuBuilder.Callback &#123;</span><br><span class="line">    // This is the top-level view of the window, containing the window decor.</span><br><span class="line">    private DecorView mDecor;</span><br><span class="line"></span><br><span class="line">    // This is the view in which the window contents are placed. It is either</span><br><span class="line">    // mDecor itself, or a child of mDecor where the contents go.</span><br><span class="line">    private ViewGroup mContentParent;</span><br><span class="line"></span><br><span class="line">    private ViewGroup mContentRoot;</span><br><span class="line">    ......</span><br><span class="line">    @Override</span><br><span class="line">    public void setContentView(int layoutResID) &#123;</span><br><span class="line">        // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span><br><span class="line">        // decor, when theme attributes and the like are crystalized. Do not check the feature</span><br><span class="line">        // before this happens.</span><br><span class="line">        if (mContentParent == null) &#123;</span><br><span class="line">            installDecor();</span><br><span class="line">        &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            mContentParent.removeAllViews();</span><br><span class="line">        &#125;</span><br><span class="line">        if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">            final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                    getContext());</span><br><span class="line">            transitionTo(newScene);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">        &#125;</span><br><span class="line">        mContentParent.requestApplyInsets();</span><br><span class="line">        final Callback cb = getCallback();</span><br><span class="line">        if (cb != null &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">            cb.onContentChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    private void installDecor() &#123;  </span><br><span class="line">        if (mDecor == null) &#123;  </span><br><span class="line">            mDecor = generateDecor();  </span><br><span class="line">            ......  </span><br><span class="line">        &#125;  </span><br><span class="line">        if (mContentParent == null) &#123;  </span><br><span class="line">            mContentParent = generateLayout(mDecor);  </span><br><span class="line">  </span><br><span class="line">            mTitleView = (TextView)findViewById(com.android.internal.R.id.title);  </span><br><span class="line">            if (mTitleView != null) &#123;  </span><br><span class="line">                if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123;  </span><br><span class="line">                    View titleContainer = findViewById(com.android.internal.R.id.title_container);  </span><br><span class="line">                    if (titleContainer != null) &#123;  </span><br><span class="line">                        titleContainer.setVisibility(View.GONE);  </span><br><span class="line">                    &#125; else &#123;  </span><br><span class="line">                        mTitleView.setVisibility(View.GONE);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    if (mContentParent instanceof FrameLayout) &#123;  </span><br><span class="line">                        ((FrameLayout)mContentParent).setForeground(null);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125; else &#123;  </span><br><span class="line">                    mTitleView.setText(mTitle);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p>通过代码分析，PhoneWindow通过以下几个步骤来创建View：</p>
<ul>
<li>创建一个DecorView对象mDecor，通过以上的图2我们知道DecorView继承自FrameLayout，它是Activity的顶级视图，Activity显示的所有界面内容都放在里面；</li>
<li>根据Activity的Feature加载不同的布局文件，这些布局文件放在frameworks/base/core/res/res/layout目录下，它们必须包含有一个id值为“content”的布局控件，加载完后解析成一个布局对象mContentRoot，接着把mContentRoot当作子布局添加到mDecor中；</li>
<li>从mContentRoot获取到id为“content”的子布局mContentParent，将我们自定义的整个布局添加到mContentParent中；</li>
</ul>
<p>最终可以通过下面的图表示activity的view布局结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-d6896fdf0a5272b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图4"></p>
<p>这样我们就知道和Activity相关的Window和View的创建过程了，接下来，如图3的时序图，ActivityThread会将创建好的视图对象Window和布局对象通过addView()方法最终传递到WindowManagerGlobal，后者就会将每个Activity对应的Window和View关联起来，最终传递到WindowManagerService，后者会统一协调整个系统的Activity视图布局，根据需要将需要渲染的activity布局内容交给另一个叫SurfaceFlinger的服务去渲染出来，这个时候我们就能在屏幕上看到具体的布局图形了。关于WindowManagerService和SurfaceFlinger涉及了另外两块更加复杂的内容，此篇文章不作详细分析。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/26/2017-2-26-source/" data-id="cjs02rbsp0000zgo94fr7berm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2015-1-19-source" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/19/2015-1-19-source/" class="article-date">
  <time datetime="2015-01-19T09:17:00.000Z" itemprop="datePublished">2015-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/android/">android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/19/2015-1-19-source/">Android触摸事件传递</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>前言：本篇博文主要分析关于onTouchEvent，dispatchTouchEvent和onInterceptTouchEvent这三个方法的作用和它们之间的关系，通过流程图来解释触摸事件（MotionEvent）是怎么在三个方法中传递的；</p>
</blockquote>
<p>为了了解三个方法之间的关系，我们通过一个demo来分析它们之间的关系，demo主要内容为在一个activity上设置两个布局控件，一个为LinearLayout，一个是TextView，两个控件都自定义重写了它们的onTouchEvent、dispatchTouchEvent和onInterceptTouchEvent方法，并用logcat打印出各个方法相应的log标记，通过触摸控件后log的打印顺序就可知道他们的调用顺序了，通过调用顺序去分析事件的传递流程，如下图所示为activity的视图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-d522f05e6aa0bbf8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>其中红色区域为Textview的视图，底下绿色区域为LinearLayout的视图，最底下蓝色区域为activity的视图；下面贴上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class GestureDemo extends Activity &#123;  </span><br><span class="line"></span><br><span class="line">    public final static String TAG = &quot;GestureDemo&quot;;  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;  </span><br><span class="line">        super.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.activity_main);   </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;  </span><br><span class="line">          </span><br><span class="line">        Log.i(TAG,&quot;Activity onTouchEvent. action=&quot;+getAction(event));  </span><br><span class="line">        return super.onTouchEvent(event);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;  </span><br><span class="line">          </span><br><span class="line">        Log.i(TAG,&quot;Activity dispatchTouchEvent. action=&quot;+getAction(ev));  </span><br><span class="line">        return super.dispatchTouchEvent(ev);  </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class MyLinearLayout extends LinearLayout &#123;  </span><br><span class="line">  </span><br><span class="line">    public MyLinearLayout(Context context) &#123;  </span><br><span class="line">        super(context);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public MyLinearLayout(Context context, AttributeSet attrs) &#123;  </span><br><span class="line">        this(context, attrs, 0);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public MyLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123;  </span><br><span class="line">        super(context,attrs,defStyleAttr);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent ev) &#123;  </span><br><span class="line">  </span><br><span class="line">        Log.i(GestureDemo.TAG,&quot;MyLinearLayout dispatchTouchEvent. action=&quot;+GestureDemo.getAction(ev));  </span><br><span class="line">        return super.dispatchTouchEvent(ev);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;  </span><br><span class="line">        Log.i(GestureDemo.TAG,&quot;MyLinearLayout onInterceptTouchEvent. action=&quot;+GestureDemo.getAction(ev));  </span><br><span class="line">        return super.onInterceptTouchEvent(ev);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;  </span><br><span class="line">        Log.i(GestureDemo.TAG,&quot;MyLinearLayout onTouchEvent. action=&quot;+GestureDemo.getAction(event));  </span><br><span class="line">        return super.onTouchEvent(event);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class MyTextView extends TextView &#123;  </span><br><span class="line">  </span><br><span class="line">    public MyTextView(Context context) &#123;  </span><br><span class="line">        super(context);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public MyTextView(Context context, AttributeSet attrs)&#123;  </span><br><span class="line">        super(context,attrs);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    MyTextView(Context context, AttributeSet attrs, int defStyleAttr)&#123;  </span><br><span class="line">        super(context,attrs,defStyleAttr);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent event) &#123;  </span><br><span class="line">        Log.i(GestureDemo.TAG,&quot;MyTextView dispatchTouchEvent. action=&quot;+GestureDemo.getAction(event));  </span><br><span class="line">        return super.dispatchTouchEvent(event);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @Override  </span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;  </span><br><span class="line">        Log.i(GestureDemo.TAG,&quot;MyTextView onTouchEvent. action=&quot;+GestureDemo.getAction(event));  </span><br><span class="line">        return super.onTouchEvent(event);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： 每一次屏幕触摸后的手势事件都是连续地由一个down事件、若干move事件和一个up事件组成，每次都必须是down事件先发生，最后一个是up事件；</p>
</blockquote>
<ul>
<li><strong>触摸事件</strong>：每一个down事件、move事件或up事件都为一个独立的触摸事件；</li>
<li><strong>手势事件</strong>：由一系列连续的触摸事件组成的一个完整的手势，比如单击手势事件为down-up, 滑动事件为down-move…move-up；</li>
</ul>
<p>下面通过逐个改变各个方法的返回值，分析它们之间的传递图；</p>
<h3 id="一、-关于onTouchEvent事件"><a href="#一、-关于onTouchEvent事件" class="headerlink" title="一、 关于onTouchEvent事件"></a>一、 关于onTouchEvent事件</h3><p>#####1. 所有方法都返回父类的方法，即MotionEvent没有被子控件消耗掉，最终只有在activity的onTouchEvent消失掉（系统默认传递流程）；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-f3daba72b7de1837?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>#####2. Activity的onTouchEvent方法返回true，其事件传递流程和上一个相同</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-153c5110ca4e2089?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>#####3. MyLinearLayout的onTouchEvent返回true</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-fd3e2922dcb2ac48?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>#####4. MyTextView的onTouchEvent返回true；</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-7b785f8002d621eb?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>总结：以上四张图中，只改动onTouchEvent的返回值，其他方法都调用父类方法，也就是传递流程都为系统默认的流程，没有人为干预，图1即是默认的系统流程，而图2,3,4通过改变onTouchEvent的返回值为true来终止事件的继续传递；从图中可知，当屏幕触摸发生时，down事件每次都是由系统先调用最底层的activity的dispatchTouchEvent事件，然后继续往上传递到最顶层控件，然后由onTouchEvent往下传递，按照默认传递顺序，如果哪个控件返回true，事件就在那个控件停止，即被这个控件消耗掉，如：activity和MyLinearLayout的onTouchEvent都返回true，那么事件只传递到MyLinearLayout的onTouchEvent，因为事件先经过MyLinearLayout的onTouchEvent，先被它截住了；而后续的move、up事件则会根据上个down事件最终在哪个控件被消耗掉，然后按照默认系统流程传递到该控件的dispatchTouchEvent后直接传递给自己的onTouchEvent，不会再往上层控件传递；</p>
</blockquote>
<h3 id="二、关于dispatchTouchEvent"><a href="#二、关于dispatchTouchEvent" class="headerlink" title="二、关于dispatchTouchEvent"></a>二、关于dispatchTouchEvent</h3><p>#####1. MyLinearLayout的dispatchTouchEvent返回true</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-28f2b8d222ccf4e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>#####2. MyTextView的dispatchTouchEvent返回true</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-d9542cfd5e416cc7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>#####3. MyLinearLayout的dispatchTouchEvent返回false</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-5f083f9fc20e5f11?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>#####4. MyTextView的dispatchTouchEvent返回false</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-cefa597d719d00f8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>总结：dispatchTouchEvent从方法名大约就可以知道其功能是分发触摸事件，该方法会根据它的返回值来决定事件要往哪个方向传递：</p>
</blockquote>
<h6 id="（1）若返回父类方法，则交由系统来决定，即为系统默认方向继续传递给上层控件的方法；"><a href="#（1）若返回父类方法，则交由系统来决定，即为系统默认方向继续传递给上层控件的方法；" class="headerlink" title="（1）若返回父类方法，则交由系统来决定，即为系统默认方向继续传递给上层控件的方法；"></a>（1）若返回父类方法，则交由系统来决定，即为系统默认方向继续传递给上层控件的方法；</h6><h6 id="（2）若返回true，则不再继续传递，传递到这个方法为止，即这个方法消耗了事件；"><a href="#（2）若返回true，则不再继续传递，传递到这个方法为止，即这个方法消耗了事件；" class="headerlink" title="（2）若返回true，则不再继续传递，传递到这个方法为止，即这个方法消耗了事件；"></a>（2）若返回true，则不再继续传递，传递到这个方法为止，即这个方法消耗了事件；</h6><h6 id="（3）若返回false，事件传递到该方法后，事件退回到底下的父控件，继续往系统默认方向传递；如图8所示，MyTextView的dispatchTouchEvent返回false，事件退回到MyLinearLayout的onInterceptTouchEvent，继续往MyLinearLayout的onTouchEvent传递，即相当于以MyLinearLayout为最顶层控件；"><a href="#（3）若返回false，事件传递到该方法后，事件退回到底下的父控件，继续往系统默认方向传递；如图8所示，MyTextView的dispatchTouchEvent返回false，事件退回到MyLinearLayout的onInterceptTouchEvent，继续往MyLinearLayout的onTouchEvent传递，即相当于以MyLinearLayout为最顶层控件；" class="headerlink" title="（3）若返回false，事件传递到该方法后，事件退回到底下的父控件，继续往系统默认方向传递；如图8所示，MyTextView的dispatchTouchEvent返回false，事件退回到MyLinearLayout的onInterceptTouchEvent，继续往MyLinearLayout的onTouchEvent传递，即相当于以MyLinearLayout为最顶层控件；"></a>（3）若返回false，事件传递到该方法后，事件退回到底下的父控件，继续往系统默认方向传递；如图8所示，MyTextView的dispatchTouchEvent返回false，事件退回到MyLinearLayout的onInterceptTouchEvent，继续往MyLinearLayout的onTouchEvent传递，即相当于以MyLinearLayout为最顶层控件；</h6><h3 id="三、关于onInterceptTouchEvent"><a href="#三、关于onInterceptTouchEvent" class="headerlink" title="三、关于onInterceptTouchEvent"></a>三、关于onInterceptTouchEvent</h3><p>#####1. MyLinearLayout的onInterceptTouchEvent返回true</p>
<p><img src="http://upload-images.jianshu.io/upload_images/3334280-a5d16a12f4083db4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<blockquote>
<p>总结：该方法只有ViewGroup的控件才会有，其父类的方法直接返回false，所以返回false就为图1中按默认方向传递了；该方法的作用就是拦截触摸事件，如果返回true，就是在当前控件拦截住触摸事件，传递给自己的onTouchEvent方法，再继续往底下控件传递给onTouchEvent，如果返回false或父类方法，就传递给它上面控件的dispatchTouchEvent；</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/01/19/2015-1-19-source/" data-id="cjs02rbtc000gzgo9j8uuvo2p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/android/">android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/11/hashtable/">散列表：如何实现word编辑器的拼写检查？</a>
          </li>
        
          <li>
            <a href="/2017/07/15/2017-7-15-source/">从一碗面想到的装饰模式</a>
          </li>
        
          <li>
            <a href="/2017/07/08/2017-7-8-source/">用王者荣耀分析策略模式</a>
          </li>
        
          <li>
            <a href="/2017/06/30/2017-6-30-source/">设计模式之工厂模式</a>
          </li>
        
          <li>
            <a href="/2017/03/14/2017-4-13-source/">Java中volatile的作用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>